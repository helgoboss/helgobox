vars: {
  d2_config{
    sketch: true
  }
}
direction: down
classes: {
  start: {
    style.fill: deepskyblue
  }
  end: {
    style.fill: lime
  }
  decision: {
    shape: diamond
    width: 100
  }
}

** {
  &label: discard*
    label: discard
    style.fill: orange
}


# (* -> *)[*] {
#   # style.animated: true
# }

source: {
  label: Source
  class: start
}

target: {
  label: Target
  class: end
}

apply_button_filter_and_fire_mode {
  label: Apply button filter and fire mode
}

source -> which_control_value_type: Control Value
which_control_value_type -> apply_button_filter_and_fire_mode: Absolute
which_control_value_type -> apply_encoder_filter: Relative

apply_encoder_filter {
  label: Apply encoder filter
}

apply_encoder_filter -> encoder_filter_result

encoder_filter_result {
  label: Result?
  class: decision
}

encoder_filter_result -> discard2: ignore
encoder_filter_result -> is_make_absolute: pass

is_make_absolute {
  label: Make absolute?
  class: decision
}


is_make_absolute -> control_relative_normal.is_value_seq_defined: no
is_make_absolute -> todo: yes

control_relative_normal {
  is_value_seq_defined {
    label: Do we have a value sequence?
    class: decision
  }
  is_value_seq_defined -> todo: yes
  is_value_seq_defined -> which_target_control_type: no
  which_target_control_type {
    label: What control type does the target have?
    class: decision
  }
  which_target_control_type -> does_target_provide_value: Absolute continuous
  which_target_control_type -> prepare_increment.apply_speed: Absolute discrete
  which_target_control_type -> prepare_increment2: Relative or virtual

  prepare_increment2 {
    apply_speed {
      label: Apply speed
    }
    apply_speed -> apply_reverse
    apply_reverse {
      label: Reverse if desired
    }
  }

  prepare_increment {
    apply_speed {
      label: Apply speed
    }
    apply_speed -> apply_reverse
    apply_reverse {
      label: Reverse if desired
    }
  }

  does_target_provide_value {
    label: Does target provide current value?
    class: decision
  }
  does_target_provide_value -> is_target_retriggerable: no
  is_target_retriggerable {
    label: Is target retriggerable?
    class: decision
  }
  is_target_retriggerable -> discard3: no
  is_target_retriggerable -> process_negative_speed: yes
  does_target_provide_value -> apply_reverse: yes

  apply_reverse {
    label: Reverse if desired
  }

  apply_reverse -> apply_step_size_min_max
  apply_step_size_min_max {
    label: Apply step size min/max
  }

  process_negative_speed {
    label: Process negative speed
  }
  process_negative_speed -> process_negative_speed_result
  process_negative_speed_result {
    label: Result?
    class: decision
  }
  process_negative_speed_result -> discard4: ignore
}

control_relative_normal.prepare_increment.apply_reverse -> hit_target_absolutely_with_unit_increment.is_wrap
control_relative_normal.prepare_increment2.apply_reverse -> target


control_relative_normal.apply_step_size_min_max -> hit_target_absolutely_with_unit_increment.is_wrap

hit_target_absolutely_with_unit_increment {
  is_wrap {
    label: Is wrap enabled?
    class: decision  
  }
  is_wrap -> apply_increment_by_clamping: no
  is_wrap -> apply_increment_by_wrapping: yes
  apply_increment_by_wrapping {
    label: Apply increment to target value wrapping target min/max
  }
  apply_increment_by_clamping {
    label: Apply increment to target value clamping target min/max
  }
}

hit_target_absolutely_with_unit_increment.apply_increment_by_clamping -> hit_if_changed.is_target_retriggerable
hit_target_absolutely_with_unit_increment.apply_increment_by_wrapping -> hit_if_changed.is_target_retriggerable

control_relative_normal.process_negative_speed_result -> target: Hit with 100%

apply_button_filter_and_fire_mode -> fire_mode_result
fire_mode_result -> discard: ignore
fire_mode_result -> which_absolute_mode: pass


fire_mode_result {
  label: Result?
  class: decision
}

which_absolute_mode -> pre_process_absolute_value.is_in_source_interval: Normal
which_absolute_mode -> control_absolute_toggle_buttons.is_control_value_zero: Toggle button
which_absolute_mode -> control_absolute_incremental_buttons.is_zero_or_out_of_range: Incremental button
which_absolute_mode -> todo5: Make relative
which_absolute_mode -> todo6: Performance control

control_absolute_incremental_buttons {
  is_zero_or_out_of_range {
    label: Is value zero or out of source min/max range?
    class: decision
  }
  is_zero_or_out_of_range -> discard: yes
  is_zero_or_out_of_range -> is_make_absolute: no
  is_make_absolute {
    label: Is make-absolute enabled?
    class: decision
  }
  is_make_absolute -> todo: yes
  is_make_absolute -> is_value_seq_defined: no
  is_value_seq_defined {
    label: Do we have a value sequence?
    class: decision
  }
  is_value_seq_defined -> todo2: yes
  is_value_seq_defined -> todo3: no

}

control_absolute_toggle_buttons {
  is_control_value_zero {
    label: "Is control value zero?"
    class: decision
  }
  is_control_value_zero -> discard: yes
  is_control_value_zero -> is_target_min_max_equal: no
  is_target_min_max_equal {
    label: "Is target min/max equal?"
  }
  is_target_min_max_equal -> choose_zero_or_target_max: yes
  is_target_min_max_equal -> choose_target_min_or_max: no
  choose_zero_or_target_max {
    label: "Choose zero or target max"
  }
  choose_target_min_or_max {
    label: "Choose target min or max"
  }
}

control_absolute_toggle_buttons.choose_zero_or_target_max -> target
control_absolute_toggle_buttons.choose_target_min_or_max -> target

which_absolute_mode {
  label: What's the absolute mode?
  class: decision
}

which_control_value_type {
  label: Which type of control value do we have?
  class: decision
}

pre_process_absolute_value {
  is_in_source_interval {
    label: Is source value within Source Min/Max range?
    class: decision
  }
  out_of_range {
    label: Apply out-of-range behavior
  }
  is_in_source_interval -> out_of_range: Out of range
  is_in_source_interval -> source_min_max: Within range
  out_of_range -> out_of_range_result
  out_of_range_result -> discard: ignore
  out_of_range_result  -> source_min_max: pass
  source_min_max {
    label: Normalize value to source min/max
  }
  out_of_range_result {
    label: Result?
    class: decision
  }
}
pre_process_absolute_value.source_min_max -> prepare_absolute_value_no_performance_mode.control_transformation

prepare_absolute_value_no_performance_mode {
  control_transformation {
    label: Apply EEL control transformation
  }
  reverse {
    label: Reverse value if desired
  }
  target_min_max {
    label: Denormalize value to target min/max
  }
  round_target_value {
    label: Round value if desired
  }
  value_sequence {
    label: Pick value from sequence
  }
  control_transformation -> control_transformation_result
  control_transformation_result -> reverse: absolute
  control_transformation_result -> todo10: relative
  reverse -> is_value_seq_defined
  is_value_seq_defined-> value_sequence: yes
  is_value_seq_defined-> target_min_max: no
  target_min_max-> round_target_value

  control_transformation_result {
    label: Result?
    class: decision
  }

  is_value_seq_defined {
    label: Do we have a value sequence?
    class: decision
  }
}

prepare_absolute_value_no_performance_mode.round_target_value-> hit_target_considering_max_jump.does_target_provide_value

hit_target_considering_max_jump {
  does_target_provide_value -> which_takeover_mode: Yes (real target)
  which_takeover_mode -> takeover_mode: else
  takeover_mode -> takover_mode_result
  takover_mode_result -> discard: ignore
  takeover_mode {
    label: Apply special takeover mode
  }
  does_target_provide_value {
    label: Does the target provide a current value?
    class: decision
  }
  which_takeover_mode {
    label: What's the takeover mode?
    class: decision
  }
  takover_mode_result {
    label: Result?
    class: decision
  }
}
prepare_absolute_value_no_performance_mode.value_sequence -> hit_target_considering_max_jump.does_target_provide_value

hit_target_considering_max_jump.does_target_provide_value -> target: No (could be virtual target)
hit_target_considering_max_jump.which_takeover_mode -> hit_if_changed.is_target_retriggerable: Normal
hit_target_considering_max_jump.takover_mode_result -> hit_if_changed.is_target_retriggerable: pass

hit_if_changed {
  is_target_retriggerable-> does_target_have_desired_value: no
  does_target_have_desired_value -> discard: yes
  is_target_retriggerable {
    label: Is target retriggerable?
    class: decision
  }
  does_target_have_desired_value {
    label: Does target already have the desired value?
    class: decision
  }
}
hit_if_changed.is_target_retriggerable -> target: yes
hit_if_changed.does_target_have_desired_value -> target: no